#!/bin/sh /etc/rc.common

START=99
USE_PROCD=1

FW_TABLE=80
FW_MARK=80
DNS_MARK=53

start_service() {
    config_load mihomo

    local enabled
    config_get_bool enabled "config" "enabled" 0

    if [ "${enabled}" == 0 ]; then
        return 0
    fi

    # paths
    local home_dir run_dir run_profile_path run_ui_path run_ui_dir
    home_dir="/etc/mihomo"
    run_dir="${home_dir}/run"
    run_profile_path="${run_dir}/config.yaml"
    run_ui_dir="${run_dir}/ui"
    run_ui_razord_path="${run_ui_dir}/razord.tar.gz"
    run_ui_razord_src_dir="${run_ui_dir}/Razord-meta-gh-pages"
    run_ui_razord_dir="${run_ui_dir}/razord"
    run_ui_yacd_path="${run_ui_dir}/yacd.tar.gz"
    run_ui_yacd_src_dir="${run_ui_dir}/Yacd-meta-gh-pages"
    run_ui_yacd_dir="${run_ui_dir}/yacd"
    run_ui_metacubexd_path="${run_ui_dir}/metacubexd.tar.gz"
    run_ui_metacubexd_src_dir="${run_ui_dir}/metacubexd-gh-pages"
    run_ui_metacubexd_dir="${run_ui_dir}/metacubexd"
    geoip_mmdb_path="${run_dir}/Country.mmdb"
    geoip_dat_path="${run_dir}/GeoIP.dat"
    geosite_path="${run_dir}/GeoSite.dat"
    # init dir/file
    if [ -f "${run_profile_path}" ]; then
        rm -f "${run_profile_path}"
    fi
    # download profile
    local profile
    config_get      profile                 "config" "profile"
    curl -s -L -o "${run_profile_path}" "${profile}"
    # download ui
    local ui_razord ui_razord_url ui_yacd ui_yacd_url ui_metacubexd ui_metacubexd_url
    config_get_bool ui_razord               "mixin" "ui_razord"             0
    config_get      ui_razord_url           "mixin" "ui_razord_url"
    config_get_bool ui_yacd                 "mixin" "ui_yacd"               0
    config_get      ui_yacd_url             "mixin" "ui_yacd_url"
    config_get_bool ui_metacubexd           "mixin" "ui_metacubexd"         0
    config_get      ui_metacubexd_url       "mixin" "ui_metacubexd_url"
    download_ui "${ui_razord}"      "${ui_razord_url}"      "${run_ui_razord_path}"     "${run_ui_dir}" "${run_ui_razord_src_dir}"      "${run_ui_razord_dir}"
    download_ui "${ui_yacd}"        "${ui_yacd_url}"        "${run_ui_yacd_path}"       "${run_ui_dir}" "${run_ui_yacd_src_dir}"        "${run_ui_yacd_dir}"
    download_ui "${ui_metacubexd}"  "${ui_metacubexd_url}"  "${run_ui_metacubexd_path}" "${run_ui_dir}" "${run_ui_metacubexd_src_dir}"  "${run_ui_metacubexd_dir}"
    # download geox files
    local geoip_mmdb_url geoip_dat_url geosite_url
    config_get      geoip_mmdb_url          "mixin" "geoip_mmdb_url"
    config_get      geoip_dat_url           "mixin" "geoip_dat_url"
    config_get      geosite_url             "mixin" "geosite_url"
    if [ ! -f "${geoip_mmdb_path}" ]; then
        curl -s -L -o "${geoip_mmdb_path}" "${geoip_mmdb_url}"
    fi
    if [ ! -f "${geoip_dat_path}" ]; then
        curl -s -L -o "${geoip_dat_path}" "${geoip_dat_url}"
    fi
    if [ ! -f "${geosite_path}" ]; then
        curl -s -L -o "${geosite_path}" "${geosite_url}"
    fi
    # load mixin
    # global
    local mode match_process unify_delay tcp_concurrent
    config_get      mode                    "mixin" "mode"
    config_get      match_process           "mixin" "match_process"
    config_get_bool unify_delay             "mixin" "unify_delay"           0
    config_get_bool tcp_concurrent          "mixin" "tcp_concurrent"        0
    # api
    local api_port api_secret selection_cache
    config_get      api_port                "mixin" "api_port"              "9090"
    config_get      api_secret              "mixin" "api_secret"            "666666"
    config_get_bool selection_cache         "mixin" "selection_cache"       0
    # inbound
    local allow_lan http_port socks_port mixed_port redir_port tproxy_port
    config_get_bool allow_lan               "mixin" "allow_lan"             0
    config_get      http_port               "mixin" "http_port"             "8080"
    config_get      socks_port              "mixin" "socks_port"            "1080"
    config_get      mixed_port              "mixin" "mixed_port"            "7890"
    config_get      redir_port              "mixin" "redir_port"            "7891"
    config_get      tproxy_port             "mixin" "tproxy_port"           "7892"
    # dns
    local dns_port dns_mode fake_ip_range fake_ip_cache
    config_get      dns_port                "mixin" "dns_port"              "1053"
    config_get      dns_mode                "mixin" "dns_mode"
    config_get      fake_ip_range           "mixin" "fake_ip_range"         "198.18.0.1/16"
    config_get_bool fake_ip_cache           "mixin" "fake_ip_cache"         0
    # geox
    local geoip_format geodata_loader geox_auto_update geox_update_interval
    config_get      geoip_format            "mixin" "geoip_format"
    config_get      geodata_loader          "mixin" "geodata_loader"
    config_get_bool geox_auto_update        "mixin" "geox_auto_update"      0
    config_get      geox_update_interval    "mixin" "geox_update_interval"  "24"
    # mark
    local mihomo_mark
    config_get      mihomo_mark             "proxy" "routing_mark"          "255"
    # mixin config
    # global
    $(mode="${mode}"                                  yq e '.mode = env(mode)'                                    -i "${run_profile_path}")
    $(match_process="${match_process}"                yq e '.find-process-mode = env(match_process)'              -i "${run_profile_path}")
    $(unify_delay="${unify_delay}"                    yq e '.unified-delay = env(unify_delay) == 1'               -i "${run_profile_path}")
    $(tcp_concurrent="${tcp_concurrent}"              yq e '.tcp-concurrent = env(tcp_concurrent) == 1'           -i "${run_profile_path}")
    # api
    $(ui_path="ui"                                    yq e '.external-ui = env(ui_path)'                          -i "${run_profile_path}")
    $(api_listen="0.0.0.0:${api_port}"                yq e '.external-controller = env(api_listen)'               -i "${run_profile_path}")
    $(api_secret="${api_secret}"                      yq e '.secret = env(api_secret)'                            -i "${run_profile_path}")
    $(selection_cache="${selection_cache}"            yq e '.profile.store-selected = env(selection_cache) == 1'  -i "${run_profile_path}")
    # inbound
    $(allow_lan="${allow_lan}"                        yq e '.allow-lan = env(allow_lan) == 1'                     -i "${run_profile_path}")
    $(http_port="${http_port}"                        yq e '.port = env(http_port)'                               -i "${run_profile_path}")
    $(socks_port="${socks_port}"                      yq e '.socks-port = env(socks_port)'                        -i "${run_profile_path}")
    $(mixed_port="${mixed_port}"                      yq e '.mixed-port = env(mixed_port)'                        -i "${run_profile_path}")
    $(redir_port="${redir_port}"                      yq e '.redir-port = env(redir_port)'                        -i "${run_profile_path}")
    $(tproxy_port="${tproxy_port}"                    yq e '.tproxy-port = env(tproxy_port)'                      -i "${run_profile_path}")
    # dns
    $(dns_enable="true"                               yq e '.dns.enable = env(dns_enable)'                        -i "${run_profile_path}")
    $(dns_listen="0.0.0.0:${dns_port}"                yq e '.dns.listen = env(dns_listen)'                        -i "${run_profile_path}")
    $(dns_mode="${dns_mode}"                          yq e '.dns.enhanced-mode = env(dns_mode)'                   -i "${run_profile_path}")
    $(fake_ip_range="${fake_ip_range}"                yq e '.dns.fake-ip-range = env(fake_ip_range)'              -i "${run_profile_path}")
    $(fake_ip_cache="${fake_ip_cache}"                yq e '.profile.store-fake-ip = env(fake_ip_cache) == 1'     -i "${run_profile_path}")
    # geox
    $(geoip_format="${geoip_format}"                  yq e '.geodata-mode = env(geoip_format) == "dat"'           -i "${run_profile_path}")
    $(geodata_loader="${geodata_loader}"              yq e '.geodata-loader = env(geodata_loader)'                -i "${run_profile_path}")
    $(geoip_mmdb_url="${geoip_mmdb_url}"              yq e '.geox-url.mmdb = env(geoip_mmdb_url)'                 -i "${run_profile_path}")
    $(geoip_dat_url="${geoip_dat_url}"                yq e '.geox-url.geoip = env(geoip_dat_url)'                 -i "${run_profile_path}")
    $(geosite_url="${geosite_url}"                    yq e '.geox-url.geosite = env(geosite_url)'                 -i "${run_profile_path}")
    $(geox_auto_update="${geox_auto_update}"          yq e '.geo-auto-update = env(geox_auto_update) == 1'        -i "${run_profile_path}")
    $(geox_update_interval="${geox_update_interval}"  yq e '.geo-update-interval = env(geox_update_interval)'     -i "${run_profile_path}")
    # mark
    $(mihomo_mark="${mihomo_mark}"                    yq e '.routing-mark = env(mihomo_mark)'                     -i "${run_profile_path}")
    # start process
    procd_open_instance
    procd_set_param command /usr/bin/mihomo
    procd_append_param command -d "${run_dir}"
    procd_set_param respawn
    procd_close_instance
    # hijack
    local transparent_proxy
    config_get_bool transparent_proxy "proxy" "transparent_proxy" 0
    if [ "${transparent_proxy}" == 1 ]; then
        # transparent proxy
        ip rule add fwmark "${FW_MARK}" table "${FW_TABLE}"
        ip route add local default dev lo table "${FW_TABLE}"
        nft -f "${home_dir}/hijack.nft" -D FW_MARK="${FW_MARK}" -D DNS_MARK="${DNS_MARK}" -D MIHOMO_MARK="${mihomo_mark}" -D TPROXY_PORT="${tproxy_port}" -D DNS_PORT="${dns_port}"
        # router proxy
        local router_proxy
        config_get_bool router_proxy "proxy" "router_proxy" 0
        if [ "${router_proxy}" == 0 ]; then
            nft delete chain ip mihomo nat_output
            nft delete chain ip mihomo mangle_output
        fi
        # access control
        local access_control_mode
        config_get access_control_mode "proxy" "access_control_mode"
        config_list_foreach "proxy" "acl_ip" add_acl_ip
        config_list_foreach "proxy" "acl_mac" add_acl_mac
        if [ "${access_control_mode}" == "allow" ]; then
            nft flush chain ip mihomo dns_hijack
            nft add rule ip mihomo dns_hijack jump allow_dns_hijack
            nft flush chain ip mihomo proxy
            nft add rule ip mihomo proxy jump allow_proxy
        elif [ "${access_control_mode}" == "block" ]; then
            nft flush chain ip mihomo dns_hijack
            nft add rule ip mihomo dns_hijack jump block_dns_hijack
            nft flush chain ip mihomo proxy
            nft add rule ip mihomo proxy jump block_proxy
        fi
        # exclusion
        add_firewall_exclusion
        add_upnp_exclusion
        # reload config
        config_load mihomo
    fi
    # cron
    local scheduled_restart cron_exp
    config_get scheduled_restart "config" "scheduled_restart"
    config_get cron_exp "config" "cron_exp"
    if [[ "${scheduled_restart}" == 1 && -n "${cron_exp}" ]]; then
        echo "${cron_exp} /etc/init.d/mihomo restart #mihomo" >> "/etc/crontabs/root"
    fi
}

stop_service() {
    # delete hijack
    ip rule del table "${FW_TABLE}" >/dev/null 2>&1
    ip route del local default dev lo table "${FW_TABLE}" >/dev/null 2>&1
    nft delete table ip mihomo >/dev/null 2>&1
    # delete cron
    sed -i '/#mihomo/d' "/etc/crontabs/root" >/dev/null 2>&1
}

reload_service() {
    stop
    start
}

service_triggers() {
    procd_add_reload_trigger "mihomo"
}

download_ui() {
    local enabled=$1
    local url=$2
    local file_path=$3
    local file_dir=$4
    local src_dir=$5
    local dest_dir=$6
    if [ "${enabled}" == 1 ]; then
        if [ ! -d "${dest_dir}" ]; then
            curl -s -L -o "${file_path}" "${url}"
            tar -x -z -f "${file_path}" -C "${file_dir}"
            rm -f "${file_path}"
            mv "${src_dir}" "${dest_dir}"
        fi
    else
        if [ -d "${dest_dir}" ]; then
            rm -rf "${dest_dir}"
        fi
    fi
}

add_acl_ip() {
    nft add element ip mihomo acl_ip { "$1" }
}

add_acl_mac() {
    nft add element ip mihomo acl_mac { "$1" }
}

add_firewall_exclusion() {
    config_load firewall
    config_foreach add_firewall_rule_exclusion "rule"
    config_foreach add_firewall_redirect_exclusion "redirect"
}

add_firewall_rule_exclusion() {
    local section="$1"

    local enabled name proto src dest dest_ip dest_port family
    config_get enabled      "${section}" "enabled"
    config_get name         "${section}" "name"
    config_get proto        "${section}" "proto"
    config_get src          "${section}" "src"
    config_get dest         "${section}" "dest"
    config_get dest_port    "${section}" "dest_port"
    config_get family       "${section}" "family"

    if [[ "${enabled}" == 0 || -z "${src}" || -n "${dest}" || -z "${dest_port}" || "${family}" == "ipv6" ]]; then
        return 0
    fi

    local tcp=0
    local udp=0
    if [[ -z  "${proto}" || "${proto}" == "all" ]]; then
        tcp=1
        udp=1
    else
        for p in "${proto}"; do
            [ "${p}" == "tcp" ] && tcp=1
            [ "${p}" == "udp" ] && udp=1
        done
    fi

    if [ "${tcp}" == 1 ]; then
        for port in "${dest_port}"; do
            nft add element ip mihomo router_exclusion { tcp . "${port}" }
        done
    fi
    if [ "${udp}" == 1 ]; then
        for port in "${dest_port}"; do
            nft add element ip mihomo router_exclusion { udp . "${port}" }
        done
    fi
}

add_firewall_redirect_exclusion() {
    local section="$1"

    local enabled name proto dest dest_ip dest_port
    config_get enabled      "${section}" "enabled"
    config_get name         "${section}" "name"
    config_get proto        "${section}" "proto"
    config_get src_dport    "${section}" "src_dport"
    config_get dest         "${section}" "dest"
    config_get dest_ip      "${section}" "dest_ip"
    config_get dest_port    "${section}" "dest_port"

    if [ "${enabled}" == 0 ]; then
        return 0
    fi

    local tcp=0
    local udp=0
    if [[ -z  "${proto}" || "${proto}" == "all" ]]; then
        tcp=1
        udp=1
    else
        for p in "${proto}"; do
            [ "${p}" == "tcp" ] && tcp=1
            [ "${p}" == "udp" ] && udp=1
        done
    fi

    if [ -z "${dest_port}" ]; then
        dest_port="${src_dport}"
    fi

    if [[ -z "${dest}" || -z "${dest_ip}" ]]; then
        if [ "${tcp}" == 1 ]; then
            nft add element ip mihomo router_exclusion { tcp . "${dest_port}" }
        fi
        if [ "${udp}" == 1 ]; then
            nft add element ip mihomo router_exclusion { udp . "${dest_port}" }
        fi
    else
        if [ "${tcp}" == 1 ]; then
            nft add element ip mihomo exclusion { tcp . "${dest_ip}" . "${dest_port}" }
        fi
        if [ "${udp}" == 1 ]; then
            nft add element ip mihomo exclusion { udp . "${dest_ip}" . "${dest_port}" }
        fi
    fi
}

add_upnp_exclusion() {
    config_load upnpd

    local enabled upnp_lease_file
    config_get enabled          "config" "enabled"          0
    config_get upnp_lease_file  "config" "upnp_lease_file"

    if [[ "${enabled}" == 0 || ! -s "${upnp_lease_file}" ]]; then
        return 0
    fi

    local lease lease_proto lease_src_ip lease_src_port

    cat "${upnp_lease_file}" | while read line
    do
        lease_proto=$(echo "${line}" | cut -d ':' -f 0)
        lease_src_ip=$(echo "${line}" | cut -d ':' -f 2)
        lease_src_port=$(echo "${line}" | cut -d ':' -f 3)
        nft add element ip mihomo exclusion { "${lease_proto,,}" . "${lease_src_ip}" . "${lease_src_port}" }
    done
}